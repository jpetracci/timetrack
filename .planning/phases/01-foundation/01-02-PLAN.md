---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - lib/state/projects_state.dart
  - lib/state/timer_state.dart
  - lib/state/timer_controller.dart
  - lib/services/local_storage.dart
  - lib/main.dart
autonomous: true
must_haves:
  truths:
    - "User can start a timer for a project with one tap"
    - "Starting a new project timer auto-stops the previous project"
    - "Active timer state restores after app restart"
  artifacts:
    - path: "lib/state/timer_state.dart"
      provides: "Timer state model with active project and running entry"
      contains: "class TimerState"
    - path: "lib/state/timer_controller.dart"
      provides: "Start/stop/switch timer logic with periodic tick"
      contains: "class TimerController"
    - path: "lib/state/projects_state.dart"
      provides: "Projects state and creation logic"
      contains: "class ProjectsState"
  key_links:
    - from: "lib/state/timer_controller.dart"
      to: "lib/services/local_storage.dart"
      via: "persist entries and active timer snapshot"
      pattern: "LocalStorage"
    - from: "lib/state/timer_controller.dart"
      to: "Timer.periodic"
      via: "ticker for running duration"
      pattern: "Timer\\.periodic"
---

<objective>
Implement core timer and project state logic with auto-stop switching and persistence restore.

Purpose: Make the timer behavior correct and durable before UI wiring.
Output: State controllers for projects and timer with persistence integration.
</objective>

<execution_context>
@/Users/joel/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/joel/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build timer and projects state controllers</name>
  <files>lib/state/projects_state.dart, lib/state/timer_state.dart, lib/state/timer_controller.dart</files>
  <action>
    Create `ProjectsState` to hold list of projects and active project id.
    Create `TimerState` to track running entry, start time, and elapsed duration.
    Implement `TimerController` (Riverpod StateNotifier/Notifier) with:
    - `start(projectId)` to start timing and set active project
    - `stop()` to stop current timer and finalize a TimeEntry
    - `switchTo(projectId)` to auto-stop current and start new one
    Use `Timer.periodic` to update elapsed duration while running.
  </action>
  <verify>flutter analyze</verify>
  <done>Timer state supports one-tap start/stop and project switching with auto-stop.</done>
</task>

<task type="auto">
  <name>Task 2: Restore and persist timer state via SharedPreferences</name>
  <files>lib/state/timer_controller.dart, lib/services/local_storage.dart, lib/main.dart</files>
  <action>
    Extend `LocalStorage` with `loadActiveTimer` and `saveActiveTimer` for running snapshot.
    On app startup, hydrate projects and entries, then restore any running timer using stored start time.
    Persist entries and active timer state on start/stop/switch.
    Ensure stop clears active timer snapshot to avoid phantom timers on restart.
  </action>
  <verify>flutter analyze</verify>
  <done>Active timer and entries survive app restart with correct elapsed time.</done>
</task>

</tasks>

<verification>
flutter analyze
</verification>

<success_criteria>
Timer logic enforces auto-stop on project switch and restores running state after restart.
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
